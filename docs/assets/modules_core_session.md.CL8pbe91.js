import{_ as i,o as a,c as l,a as r}from"./app.D6kRkAg9.js";import"./chunks/markjs.l6TISjdC.js";import"./chunks/minisearch.DigTKvvb.js";const m=JSON.parse('{"title":"Session (core)","description":"","frontmatter":{},"headers":[],"relativePath":"modules/core/session.md","filePath":"modules/core/session.md","lastUpdated":1770805184000}'),t={name:"modules/core/session.md"};function s(o,e,n,c,u,p){return a(),l("div",null,[...e[0]||(e[0]=[r(`<h1 id="session-core" tabindex="-1">Session (core) <a class="header-anchor" href="#session-core" aria-label="Permalink to &quot;Session (core)&quot;">​</a></h1><p>The <strong>Session</strong> component represents a single client connection.</p><p>It is responsible for:</p><ul><li>Reading HTTP requests</li><li>Enforcing limits (body size, timeouts)</li><li>Applying basic WAF checks</li><li>Dispatching to the Router</li><li>Handling heavy vs light routes</li><li>Writing HTTP responses</li><li>Managing keep-alive connections</li></ul><hr><h2 id="architecture-role" tabindex="-1">Architecture Role <a class="header-anchor" href="#architecture-role" aria-label="Permalink to &quot;Architecture Role&quot;">​</a></h2><p>The execution chain is:</p><p>TCP Socket<br> → Session<br> → Router<br> → Handler<br> → Response</p><p>Each client connection owns one <code>Session</code> instance.</p><hr><h2 id="responsibilities" tabindex="-1">Responsibilities <a class="header-anchor" href="#responsibilities" aria-label="Permalink to &quot;Responsibilities&quot;">​</a></h2><h3 id="_1-asynchronous-request-reading" tabindex="-1">1. Asynchronous Request Reading <a class="header-anchor" href="#_1-asynchronous-request-reading" aria-label="Permalink to &quot;1. Asynchronous Request Reading&quot;">​</a></h3><p>Session uses Boost.Beast async read to:</p><ul><li>Parse HTTP headers and body</li><li>Enforce body size limits</li><li>Handle connection resets safely</li></ul><p>Maximum request body size (default):</p><p>10 MB</p><p>This protects the server from memory abuse.</p><hr><h3 id="_2-timeout-protection" tabindex="-1">2. Timeout Protection <a class="header-anchor" href="#_2-timeout-protection" aria-label="Permalink to &quot;2. Timeout Protection&quot;">​</a></h3><p>Each request starts a timer:</p><ul><li>Configurable via <code>Config</code></li><li>Prevents stalled connections</li><li>Automatically closes the socket if expired</li></ul><p>This avoids slowloris-style attacks.</p><hr><h3 id="_3-basic-waf-web-application-firewall" tabindex="-1">3. Basic WAF (Web Application Firewall) <a class="header-anchor" href="#_3-basic-waf-web-application-firewall" aria-label="Permalink to &quot;3. Basic WAF (Web Application Firewall)&quot;">​</a></h3><p>Session performs lightweight request filtering before routing.</p><p>Modes:</p><ul><li>off</li><li>basic</li><li>strict</li></ul><p>Checks include:</p><ul><li>Suspicious SQL keywords (SELECT, UNION, DROP, etc.)</li><li>Script injection patterns</li><li>Body size validation</li><li>Target length validation</li><li>Control character rejection</li></ul><p>In benchmark mode, WAF can be disabled.</p><p>This is not a full security layer, but a protective filter.</p><hr><h2 id="light-vs-heavy-routes" tabindex="-1">Light vs Heavy Routes <a class="header-anchor" href="#light-vs-heavy-routes" aria-label="Permalink to &quot;Light vs Heavy Routes&quot;">​</a></h2><p>Session asks the router:</p><pre><code>router.is_heavy(request)
</code></pre><p>If route is NOT heavy:</p><ul><li>Executed immediately in I/O thread</li></ul><p>If route IS heavy:</p><ul><li>Posted to configured executor</li><li>Prevents blocking I/O threads</li><li>Allows CPU/DB isolation</li></ul><p>If executor is saturated:</p><ul><li>Returns 503 Service Unavailable</li></ul><p>This separation protects latency.</p><hr><h2 id="keep-alive-handling" tabindex="-1">Keep-Alive Handling <a class="header-anchor" href="#keep-alive-handling" aria-label="Permalink to &quot;Keep-Alive Handling&quot;">​</a></h2><p>If request uses keep-alive:</p><ul><li>Session keeps socket open</li><li>Parses next request</li></ul><p>If not:</p><ul><li>Socket is gracefully closed</li></ul><p>HEAD requests are handled properly.</p><hr><h2 id="response-flow" tabindex="-1">Response Flow <a class="header-anchor" href="#response-flow" aria-label="Permalink to &quot;Response Flow&quot;">​</a></h2><p>All responses:</p><ul><li>Are written asynchronously</li><li>Use strand to ensure serialized writes</li><li>Respect keep-alive headers</li><li>Automatically set connection field</li></ul><p>Error responses are standardized.</p><hr><h2 id="error-handling-guarantees" tabindex="-1">Error Handling Guarantees <a class="header-anchor" href="#error-handling-guarantees" aria-label="Permalink to &quot;Error Handling Guarantees&quot;">​</a></h2><p>Session guarantees:</p><ul><li>No uncaught exceptions escape async callbacks</li><li>Graceful shutdown on read/write errors</li><li>Proper socket close on failure</li><li>No double writes (strand protected)</li></ul><hr><h2 id="security-safeguards" tabindex="-1">Security Safeguards <a class="header-anchor" href="#security-safeguards" aria-label="Permalink to &quot;Security Safeguards&quot;">​</a></h2><p>Session protects against:</p><ul><li>Oversized payloads</li><li>Malformed requests</li><li>Suspicious body patterns</li><li>Control character injection</li><li>Basic SQL/XSS injection attempts</li></ul><p>It is a first defense layer, not a full firewall.</p><hr><h2 id="thread-safety" tabindex="-1">Thread Safety <a class="header-anchor" href="#thread-safety" aria-label="Permalink to &quot;Thread Safety&quot;">​</a></h2><ul><li>Writes are serialized using <code>asio::strand</code></li><li>Heavy route execution is offloaded to executor</li><li>No shared mutable state across sessions</li></ul><p>Each Session is independent.</p><hr><h2 id="performance-model" tabindex="-1">Performance Model <a class="header-anchor" href="#performance-model" aria-label="Permalink to &quot;Performance Model&quot;">​</a></h2><p>Fast path (light routes):</p><ul><li>No thread hop</li><li>Direct router dispatch</li><li>Minimal overhead</li></ul><p>Heavy path:</p><ul><li>Executor dispatch</li><li>Safe isolation from I/O threads</li></ul><p>Timeout and body limit checks are constant-time.</p><hr><h2 id="when-to-use" tabindex="-1">When To Use <a class="header-anchor" href="#when-to-use" aria-label="Permalink to &quot;When To Use&quot;">​</a></h2><p>Session is automatically used by HTTPServer.</p><p>You rarely instantiate it manually.</p><p>It exists to:</p><ul><li>Encapsulate connection lifecycle</li><li>Protect I/O threads</li><li>Provide safe async boundaries</li></ul><hr><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p>Session is the per-connection runtime engine of Vix.</p><p>It provides:</p><ul><li>Async parsing</li><li>WAF filtering</li><li>Heavy route offloading</li><li>Timeout enforcement</li><li>Safe response writing</li><li>Keep-alive support</li></ul><p>It forms the execution boundary between the network layer and application logic.</p>`,86)])])}const b=i(t,[["render",s]]);export{m as __pageData,b as default};
