import{_ as a,o as i,c as e,a as t}from"./app.BtOALlPB.js";import"./chunks/markjs.l6TISjdC.js";import"./chunks/minisearch.DigTKvvb.js";const u=JSON.parse('{"title":"spawn","description":"","frontmatter":{},"headers":[],"relativePath":"modules/async/spawn.md","filePath":"modules/async/spawn.md","lastUpdated":1770918867000}'),n={name:"modules/async/spawn.md"};function l(h,s,p,d,o,k){return i(),e("div",null,[...s[0]||(s[0]=[t(`<h1 id="spawn" tabindex="-1">spawn <a class="header-anchor" href="#spawn" aria-label="Permalink to &quot;spawn&quot;">​</a></h1><p><code>spawn</code> is the tiny &quot;fire and forget&quot; helper for Vix async tasks.</p><p>It takes a <code>task&lt;void&gt;</code>, schedules it onto an <code>io_context</code> scheduler, and lets it run without returning anything to the caller.</p><p>This is useful for background work where you do not want to propagate a result, for example telemetry, cache warmups, periodic refresh, or &quot;best effort&quot; cleanup.</p><h2 id="what-it-provides" tabindex="-1">What it provides <a class="header-anchor" href="#what-it-provides" aria-label="Permalink to &quot;What it provides&quot;">​</a></h2><ul><li><code>vix::async::core::spawn_detached(io_context&amp;, task&lt;void&gt;)</code></li><li>An internal helper coroutine type: <code>detail::detached_task</code></li></ul><p><code>spawn_detached</code> is intentionally small and deterministic:</p><ul><li>The coroutine is posted to <code>io_context</code> via <code>ctx.post(handle)</code>.</li><li>The coroutine frame destroys itself at the end (final suspend).</li><li>Exceptions are swallowed by design (detached tasks have no observer).</li></ul><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spawn_detached</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">io_context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="behavior" tabindex="-1">Behavior <a class="header-anchor" href="#behavior" aria-label="Permalink to &quot;Behavior&quot;">​</a></h3><ol><li>Wrap the provided <code>task&lt;void&gt;</code> into an internal coroutine (<code>make_detached</code>).</li><li>Post the wrapper coroutine handle to the <code>io_context</code> scheduler.</li><li>The wrapper <code>co_await</code>s the original task.</li><li>At completion, <code>final_suspend</code> destroys the wrapper frame.</li></ol><h2 id="how-it-works-internally" tabindex="-1">How it works internally <a class="header-anchor" href="#how-it-works-internally" aria-label="Permalink to &quot;How it works internally&quot;">​</a></h2><h3 id="detail-detached-task" tabindex="-1"><code>detail::detached_task</code> <a class="header-anchor" href="#detail-detached-task" aria-label="Permalink to &quot;\`detail::detached_task\`&quot;">​</a></h3><p><code>detached_task</code> is a dedicated coroutine type with a promise that:</p><ul><li>starts suspended (<code>initial_suspend = suspend_always</code>)</li><li>self-destroys at final suspend</li><li>swallows exceptions in <code>unhandled_exception()</code></li></ul><p>That makes it safe as a scheduler posted coroutine handle:</p><ul><li>it will not leak (self-destruction)</li><li>it will not crash the runtime due to an unobserved exception</li></ul><h3 id="detail-make-detached-task-void" tabindex="-1"><code>detail::make_detached(task&lt;void&gt;)</code> <a class="header-anchor" href="#detail-make-detached-task-void" aria-label="Permalink to &quot;\`detail::make_detached(task&lt;void&gt;)\`&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> detached_task</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make_detached</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  co_await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  co_return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This wrapper exists so <code>spawn_detached</code> can post a coroutine handle that has a self-destroying final suspend, even if the original task implementation is updated later.</p><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><p>A simple &quot;background job&quot; that runs on the scheduler thread:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix/async/core/io_context.hpp&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix/async/core/spawn.hpp&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // do something best-effort</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // if you throw here, it will be swallowed (detached)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  co_return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  io_context ctx;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  spawn_detached</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="notes-and-best-practices" tabindex="-1">Notes and best practices <a class="header-anchor" href="#notes-and-best-practices" aria-label="Permalink to &quot;Notes and best practices&quot;">​</a></h2><ul><li><code>spawn_detached</code> is for <code>task&lt;void&gt;</code> only. If you need a value, return a <code>task&lt;T&gt;</code> and <code>co_await</code> it somewhere.</li><li>Because exceptions are swallowed, treat detached tasks as &quot;best effort&quot;. <ul><li>If you need observability, add logging inside the task body or later connect <code>unhandled_exception()</code> to the logger.</li></ul></li><li>The work runs on the scheduler thread unless the task uses other services (cpu pool, timers, net) and awaits them.</li></ul><h2 id="related" tabindex="-1">Related <a class="header-anchor" href="#related" aria-label="Permalink to &quot;Related&quot;">​</a></h2><ul><li><code>task&lt;T&gt;</code>: coroutine result type and ownership model</li><li><code>scheduler</code>: single-thread scheduler queue and event loop</li><li><code>io_context</code>: runtime context that owns the scheduler and lazy services</li></ul>`,28)])])}const g=a(n,[["render",l]]);export{u as __pageData,g as default};
