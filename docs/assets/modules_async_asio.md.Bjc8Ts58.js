import{_ as i,o as t,c as s,a}from"./app.BpCqEuXO.js";import"./chunks/markjs.l6TISjdC.js";import"./chunks/minisearch.DigTKvvb.js";const g=JSON.parse('{"title":"asio_net_service","description":"","frontmatter":{},"headers":[],"relativePath":"modules/async/asio.md","filePath":"modules/async/asio.md","lastUpdated":1770965504000}'),o={name:"modules/async/asio.md"};function n(r,e,l,d,c,h){return t(),s("div",null,[...e[0]||(e[0]=[a(`<h1 id="asio-net-service" tabindex="-1">asio_net_service <a class="header-anchor" href="#asio-net-service" aria-label="Permalink to &quot;asio_net_service&quot;">​</a></h1><p><code>asio_net_service</code> is an internal networking service used by the Vix async runtime. It owns an independent <code>asio::io_context</code> that runs on a dedicated network thread, and it is created lazily by <code>vix::async::core::io_context::net()</code>.</p><p>This file lives in the <code>detail</code> namespace on purpose. End users typically interact with higher-level networking APIs (<code>tcp_stream</code>, <code>udp_socket</code>, <code>dns_resolver</code>, etc.), not with <code>asio_net_service</code> directly.</p><hr><h2 id="what-problem-it-solves" tabindex="-1">What problem it solves <a class="header-anchor" href="#what-problem-it-solves" aria-label="Permalink to &quot;What problem it solves&quot;">​</a></h2><p>Networking backends like Asio need an event loop (<code>asio::io_context::run()</code>) to drive async I/O completions.</p><p>Vix already has its own scheduler (<code>vix::async::core::scheduler</code>) for coroutine continuations and posted tasks. Rather than mixing scheduler internals with socket readiness, <code>asio_net_service</code> isolates networking into:</p><ul><li>its own <code>asio::io_context</code></li><li>its own dedicated thread that runs <code>ioc_.run()</code></li><li>a work guard to keep <code>run()</code> alive</li></ul><p>This separation keeps the core scheduler minimal and makes the networking backend an optional service.</p><hr><h2 id="where-it-sits-in-the-architecture" tabindex="-1">Where it sits in the architecture <a class="header-anchor" href="#where-it-sits-in-the-architecture" aria-label="Permalink to &quot;Where it sits in the architecture&quot;">​</a></h2><ul><li><code>vix::async::core::io_context</code><ul><li>owns a <code>scheduler</code> (core coroutine resumption and task queue)</li><li>lazily owns services: <ul><li><code>thread_pool</code> (CPU jobs)</li><li><code>timer</code> (deadlines)</li><li><code>signal_set</code> (signals)</li><li><code>net()</code> -&gt; <code>asio_net_service</code> (network backend)</li></ul></li></ul></li></ul><p>So the model is:</p><ul><li>scheduler thread: your main event loop calling <code>io_context.run()</code></li><li>network thread: Asio loop used by socket primitives</li><li>worker threads: optional thread pool (CPU compute)</li></ul><hr><h2 id="key-design-points" tabindex="-1">Key design points <a class="header-anchor" href="#key-design-points" aria-label="Permalink to &quot;Key design points&quot;">​</a></h2><h3 id="_1-dedicated-thread-for-networking" tabindex="-1">1) Dedicated thread for networking <a class="header-anchor" href="#_1-dedicated-thread-for-networking" aria-label="Permalink to &quot;1) Dedicated thread for networking&quot;">​</a></h3><p><code>asio_net_service</code> runs:</p><ul><li><code>net_thread_</code> calls <code>ioc_.run()</code></li></ul><p>This means networking completions happen on the net thread. Concrete networking primitives should then &quot;bridge back&quot; to the Vix scheduler thread to resume user coroutines in a predictable place.</p><h3 id="_2-work-guard-keeps-asio-alive" tabindex="-1">2) Work guard keeps Asio alive <a class="header-anchor" href="#_2-work-guard-keeps-asio-alive" aria-label="Permalink to &quot;2) Work guard keeps Asio alive&quot;">​</a></h3><p>Without a guard, <code>asio::io_context::run()</code> returns as soon as there is no pending work.</p><p>The service keeps a <code>executor_work_guard</code> alive so the Asio loop stays running even when no sockets are active yet.</p><h3 id="_3-stop-is-explicit" tabindex="-1">3) stop() is explicit <a class="header-anchor" href="#_3-stop-is-explicit" aria-label="Permalink to &quot;3) stop() is explicit&quot;">​</a></h3><p><code>stop()</code> is responsible for shutting down the Asio loop and letting the net thread exit. Destruction calls stop and joins the thread, guaranteeing a clean shutdown when <code>io_context</code> is destroyed.</p><hr><h2 id="public-surface" tabindex="-1">Public surface <a class="header-anchor" href="#public-surface" aria-label="Permalink to &quot;Public surface&quot;">​</a></h2><h3 id="constructor" tabindex="-1">Constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;Constructor&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">explicit</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> asio_net_service</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::io_context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx);</span></span></code></pre></div><ul><li>binds to the core <code>io_context</code></li><li>creates a work guard</li><li>starts the network thread</li></ul><h3 id="accessor" tabindex="-1">Accessor <a class="header-anchor" href="#accessor" aria-label="Permalink to &quot;Accessor&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">io_context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> asio_ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Used only by internal implementations to bind sockets, resolvers, timers, etc.</p><h3 id="stop" tabindex="-1">stop() <a class="header-anchor" href="#stop" aria-label="Permalink to &quot;stop()&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">noexcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>releases the guard (so Asio is allowed to finish)</li><li>calls <code>ioc_.stop()</code></li><li>requests thread shutdown</li></ul><hr><h2 id="typical-lifecycle" tabindex="-1">Typical lifecycle <a class="header-anchor" href="#typical-lifecycle" aria-label="Permalink to &quot;Typical lifecycle&quot;">​</a></h2><h3 id="lazy-creation" tabindex="-1">Lazy creation <a class="header-anchor" href="#lazy-creation" aria-label="Permalink to &quot;Lazy creation&quot;">​</a></h3><p><code>io_context</code> should create it on first <code>ctx.net()</code> call. This keeps startup cheap if the app never uses networking.</p><h3 id="shutdown-behavior" tabindex="-1">Shutdown behavior <a class="header-anchor" href="#shutdown-behavior" aria-label="Permalink to &quot;Shutdown behavior&quot;">​</a></h3><p>A typical shutdown sequence is:</p><ol><li>app calls <code>ctx.stop()</code> (stops Vix scheduler loop)</li><li><code>io_context</code> destructor triggers service cleanup</li><li><code>asio_net_service::~asio_net_service()</code> calls <code>stop()</code> and joins <code>net_thread_</code></li></ol><p>Because <code>net_thread_</code> runs independently, joining is important to avoid a dangling thread during program exit.</p><hr><h2 id="how-networking-primitives-should-integrate-with-it" tabindex="-1">How networking primitives should integrate with it <a class="header-anchor" href="#how-networking-primitives-should-integrate-with-it" aria-label="Permalink to &quot;How networking primitives should integrate with it&quot;">​</a></h2><p>Concrete networking types (TCP/UDP/DNS implementations) will usually:</p><ol><li>create Asio objects bound to <code>asio_net_service::asio_ctx()</code></li><li>start async operations on the net thread</li><li>when Asio completes, post the continuation to the Vix scheduler thread</li></ol><p>Example pattern (conceptual):</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// PSEUDO CODE for a TCP read awaitable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> on_asio_complete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error_code</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // store ec/n</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // then resume coroutine on Vix scheduler thread</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_scheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(h);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This keeps the rule simple for users:</p><ul><li>your coroutines resume on the Vix scheduler thread</li><li>networking backends run on their own threads</li></ul><hr><h2 id="threading-model-and-safety-notes" tabindex="-1">Threading model and safety notes <a class="header-anchor" href="#threading-model-and-safety-notes" aria-label="Permalink to &quot;Threading model and safety notes&quot;">​</a></h2><ul><li><code>asio::io_context</code> is safe to use from multiple threads, but Vix uses one dedicated net thread for predictability.</li><li><code>asio_ctx()</code> must outlive any sockets/resolvers created from it.</li><li><code>stop()</code> must be safe to call more than once (idempotent behavior is recommended).</li><li>Avoid calling <code>join()</code> from the net thread itself. Destruction should happen from the owning context thread.</li></ul><hr><h2 id="common-pitfalls" tabindex="-1">Common pitfalls <a class="header-anchor" href="#common-pitfalls" aria-label="Permalink to &quot;Common pitfalls&quot;">​</a></h2><h3 id="_1-forgetting-the-guard" tabindex="-1">1) Forgetting the guard <a class="header-anchor" href="#_1-forgetting-the-guard" aria-label="Permalink to &quot;1) Forgetting the guard&quot;">​</a></h3><p>If you do not keep the work guard alive, <code>ioc_.run()</code> may immediately return and networking operations will never complete.</p><h3 id="_2-resuming-coroutines-on-the-wrong-thread" tabindex="-1">2) Resuming coroutines on the wrong thread <a class="header-anchor" href="#_2-resuming-coroutines-on-the-wrong-thread" aria-label="Permalink to &quot;2) Resuming coroutines on the wrong thread&quot;">​</a></h3><p>If you resume user continuations directly from the net thread, you can create subtle race conditions because the rest of Vix assumes resumption happens on the scheduler thread.</p><p>The recommended rule is:</p><ul><li>Asio callbacks run on net thread</li><li>coroutine resumption posts back to <code>ctx.get_scheduler()</code></li></ul><h3 id="_3-stop-order" tabindex="-1">3) stop order <a class="header-anchor" href="#_3-stop-order" aria-label="Permalink to &quot;3) stop order&quot;">​</a></h3><p>If <code>io_context</code> is destroyed while networking primitives still hold references to Asio objects, you can get crashes.</p><p>Practical rule:</p><ul><li>destroy all network objects (streams, listeners, sockets) before <code>io_context</code> destruction</li><li>or ensure those objects internally handle <code>asio_ctx().stopped()</code> and early exit</li></ul><hr><h2 id="suggested-testing-checklist" tabindex="-1">Suggested testing checklist <a class="header-anchor" href="#suggested-testing-checklist" aria-label="Permalink to &quot;Suggested testing checklist&quot;">​</a></h2><p>When implementing the <code>.cpp</code> for <code>asio_net_service</code>, verify:</p><ul><li>creating the service starts the thread and <code>ioc_.run()</code> stays alive</li><li><code>stop()</code> stops <code>ioc_</code> and the thread exits</li><li><code>stop()</code> is safe to call multiple times</li><li>destructor always joins the thread</li><li>lazy creation from <code>io_context::net()</code> works and does not create services unless needed</li></ul><hr><h2 id="next-docs-that-depend-on-this" tabindex="-1">Next docs that depend on this <a class="header-anchor" href="#next-docs-that-depend-on-this" aria-label="Permalink to &quot;Next docs that depend on this&quot;">​</a></h2><p>Once <code>asio_net_service</code> exists, it becomes the backend for:</p><ul><li><code>tcp_stream</code> and <code>tcp_listener</code> implementations</li><li><code>udp_socket</code> implementation</li><li><code>dns_resolver</code> implementation</li></ul><p>Those guides should reference the same threading rule: Asio completes on net thread, coroutine resumes on scheduler thread.</p>`,76)])])}const m=i(o,[["render",n]]);export{g as __pageData,m as default};
