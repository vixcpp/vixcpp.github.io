import{_ as s,o as e,c as a,a as t}from"./app.BYybgkFJ.js";import"./chunks/markjs.l6TISjdC.js";import"./chunks/minisearch.DigTKvvb.js";const g=JSON.parse('{"title":"HTTP Server Guide (vix::server::HTTPServer)","description":"","frontmatter":{},"headers":[],"relativePath":"modules/core/server.md","filePath":"modules/core/server.md","lastUpdated":1770805184000}'),l={name:"modules/core/server.md"};function n(o,i,r,h,p,d){return e(),a("div",null,[...i[0]||(i[0]=[t(`<h1 id="http-server-guide-vix-server-httpserver" tabindex="-1">HTTP Server Guide (vix::server::HTTPServer) <a class="header-anchor" href="#http-server-guide-vix-server-httpserver" aria-label="Permalink to &quot;HTTP Server Guide (vix::server::HTTPServer)&quot;">​</a></h1><p>This guide explains how the Vix HTTP server works, how it connects to the Router and Executor, and how to run and stop it cleanly.</p><p>This guide matches the current code in:</p><ul><li><code>vix/server/HTTPServer.hpp</code></li><li><code>vix/server/HTTPServer.cpp</code></li></ul><hr><h2 id="what-httpserver-is" tabindex="-1">What HTTPServer is <a class="header-anchor" href="#what-httpserver-is" aria-label="Permalink to &quot;What HTTPServer is&quot;">​</a></h2><p><code>vix::server::HTTPServer</code> is an asynchronous HTTP server built on Boost.Asio and Boost.Beast.</p><p>It is responsible for:</p><ul><li>Binding a TCP acceptor on the configured port</li><li>Accepting connections asynchronously</li><li>Creating a <code>vix::session::Session</code> for each client socket</li><li>Running the <code>io_context</code> on a pool of I/O threads</li><li>Exposing a shared <code>vix::router::Router</code> used to dispatch requests</li><li>Periodically reporting executor metrics</li></ul><p>The server delegates request parsing and per-connection HTTP handling to <code>vix::session::Session</code>.</p><hr><h2 id="key-dependencies" tabindex="-1">Key dependencies <a class="header-anchor" href="#key-dependencies" aria-label="Permalink to &quot;Key dependencies&quot;">​</a></h2><h3 id="boost" tabindex="-1">Boost <a class="header-anchor" href="#boost" aria-label="Permalink to &quot;Boost&quot;">​</a></h3><ul><li><code>boost::asio</code> provides the I/O event loop (<code>net::io_context</code>), TCP sockets, acceptor, and async accept.</li><li><code>boost::beast::http</code> provides HTTP request/response types.</li></ul><h3 id="vix-components" tabindex="-1">Vix components <a class="header-anchor" href="#vix-components" aria-label="Permalink to &quot;Vix components&quot;">​</a></h3><ul><li><code>vix::router::Router</code>: matches method + path and invokes the registered handler.</li><li><code>vix::executor::IExecutor</code>: schedules work (used by sessions and for timers/metrics).</li><li><code>vix::session::Session</code>: handles one client connection and drives HTTP reads/writes.</li></ul><hr><h2 id="public-api" tabindex="-1">Public API <a class="header-anchor" href="#public-api" aria-label="Permalink to &quot;Public API&quot;">​</a></h2><h3 id="constructor" tabindex="-1">Constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;Constructor&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">explicit</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTTPServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::Config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">executor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::IExecutor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exec);</span></span></code></pre></div><p>What it does:</p><ul><li>Stores references to <code>Config</code> and the executor</li><li>Creates <code>io_context</code></li><li>Creates an empty <code>Router</code></li><li>Installs a default JSON 404 handler via <code>router_-&gt;setNotFoundHandler(...)</code><ul><li>Special case: if the request method is <code>HEAD</code>, it returns no body</li></ul></li></ul><h3 id="run" tabindex="-1">run() <a class="header-anchor" href="#run" aria-label="Permalink to &quot;run()&quot;">​</a></h3><p>Starts the server:</p><ul><li>Initializes and binds the acceptor if not yet open</li><li>Starts the async accept loop</li><li>Starts periodic metrics reporting</li><li>Starts I/O worker threads that call <code>io_context_-&gt;run()</code></li></ul><p>Important:</p><ul><li><code>run()</code> does not block. It starts threads and returns.</li></ul><h3 id="start-accept" tabindex="-1">start_accept() <a class="header-anchor" href="#start-accept" aria-label="Permalink to &quot;start_accept()&quot;">​</a></h3><p>Starts an async accept operation:</p><ul><li>Creates a <code>tcp::socket</code></li><li>Calls <code>acceptor_-&gt;async_accept(...)</code></li><li>On success, calls <code>handle_client(socket)</code></li><li>If stop is not requested, schedules the next accept</li></ul><h3 id="calculate-io-thread-count" tabindex="-1">calculate_io_thread_count() <a class="header-anchor" href="#calculate-io-thread-count" aria-label="Permalink to &quot;calculate_io_thread_count()&quot;">​</a></h3><p>Thread count policy:</p><ul><li>If <code>config_.getIOThreads()</code> is set and &gt; 0, it forces that value</li><li>Otherwise it uses <code>std::thread::hardware_concurrency()</code> (minimum 1)</li></ul><h3 id="getrouter" tabindex="-1">getRouter() <a class="header-anchor" href="#getrouter" aria-label="Permalink to &quot;getRouter()&quot;">​</a></h3><p>Returns the shared router:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shared_ptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Router</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Use this to register routes before calling <code>run()</code>.</p><h3 id="monitor-metrics" tabindex="-1">monitor_metrics() <a class="header-anchor" href="#monitor-metrics" aria-label="Permalink to &quot;monitor_metrics()&quot;">​</a></h3><p>Schedules a recurring timer using the executor:</p><ul><li>Every 5 seconds, reads <code>executor_-&gt;metrics()</code></li><li>Logs: pending, active, timed_out</li></ul><p>This uses:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">interval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor_, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chrono</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">seconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), ...);</span></span></code></pre></div><h3 id="stop-async" tabindex="-1">stop_async() <a class="header-anchor" href="#stop-async" aria-label="Permalink to &quot;stop_async()&quot;">​</a></h3><p>Requests shutdown:</p><ul><li>Sets <code>stop_requested_ = true</code></li><li>Closes acceptor (if open)</li><li>Stops the io_context</li></ul><p>This stops accepting new connections and causes <code>io_context_-&gt;run()</code> to return on I/O threads.</p><h3 id="stop-blocking" tabindex="-1">stop_blocking() <a class="header-anchor" href="#stop-blocking" aria-label="Permalink to &quot;stop_blocking()&quot;">​</a></h3><p>Stops and blocks until clean:</p><ul><li><code>executor_-&gt;wait_idle()</code></li><li><code>join_threads()</code></li></ul><p>Note:</p><ul><li>In the current implementation, <code>stop_blocking()</code> does not call <code>stop_async()</code>. You typically call <code>stop_async()</code> first, then <code>stop_blocking()</code>.</li></ul><h3 id="join-threads" tabindex="-1">join_threads() <a class="header-anchor" href="#join-threads" aria-label="Permalink to &quot;join_threads()&quot;">​</a></h3><p>Joins all I/O worker threads.</p><h3 id="bound-port" tabindex="-1">bound_port() <a class="header-anchor" href="#bound-port" aria-label="Permalink to &quot;bound_port()&quot;">​</a></h3><p>Returns the actual bound port:</p><ul><li>Useful when config port is <code>0</code> (ephemeral port)</li><li>Returns <code>0</code> if not bound yet</li></ul><hr><h2 id="internal-flow" tabindex="-1">Internal flow <a class="header-anchor" href="#internal-flow" aria-label="Permalink to &quot;Internal flow&quot;">​</a></h2><h3 id="_1-acceptor-initialization" tabindex="-1">1) Acceptor initialization <a class="header-anchor" href="#_1-acceptor-initialization" aria-label="Permalink to &quot;1) Acceptor initialization&quot;">​</a></h3><p><code>init_acceptor(port)</code>:</p><ul><li><code>open()</code></li><li><code>set_option(reuse_address=true)</code></li><li><code>bind()</code></li><li><code>listen()</code></li><li>stores the effective port in <code>bound_port_</code> using <code>local_endpoint().port()</code></li></ul><p>Special handling:</p><ul><li>If bind fails with address-in-use, a clearer exception message is thrown.</li></ul><h3 id="_2-accept-loop" tabindex="-1">2) Accept loop <a class="header-anchor" href="#_2-accept-loop" aria-label="Permalink to &quot;2) Accept loop&quot;">​</a></h3><p><code>start_accept()</code> calls <code>async_accept</code> and re-arms itself.</p><p>Stop logic:</p><ul><li>If <code>stop_requested_</code> is true, the loop stops re-arming accepts.</li></ul><h3 id="_3-session-creation" tabindex="-1">3) Session creation <a class="header-anchor" href="#_3-session-creation" aria-label="Permalink to &quot;3) Session creation&quot;">​</a></h3><p>When a socket is accepted:</p><ul><li><code>handle_client(socket)</code> creates a <code>vix::session::Session</code></li><li>It passes: <ul><li>socket</li><li>router</li><li>config</li><li>executor</li></ul></li><li>Calls <code>session-&gt;run()</code></li></ul><p>All request routing happens inside the session using the router.</p><h3 id="_4-i-o-threads" tabindex="-1">4) I/O threads <a class="header-anchor" href="#_4-i-o-threads" aria-label="Permalink to &quot;4) I/O threads&quot;">​</a></h3><p><code>start_io_threads()</code>:</p><ul><li>Spawns N threads</li><li>Each thread calls <code>io_context_-&gt;run()</code></li></ul><p>Linux only:</p><ul><li><code>set_affinity(i)</code> pins each I/O thread to a CPU using <code>pthread_setaffinity_np</code></li></ul><hr><h2 id="typical-usage" tabindex="-1">Typical usage <a class="header-anchor" href="#typical-usage" aria-label="Permalink to &quot;Typical usage&quot;">​</a></h2><h3 id="setup-and-run" tabindex="-1">Setup and run <a class="header-anchor" href="#setup-and-run" aria-label="Permalink to &quot;Setup and run&quot;">​</a></h3><p>Pseudo example:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::Config cfg;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">experimental</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make_threadpool_executor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HTTPServer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cfg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add_route</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">boost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">verb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::get, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/health&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">             std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make_shared</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vhttp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;...&gt;&gt;(...));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// keep main alive, or wait on a signal</span></span></code></pre></div><h3 id="graceful-shutdown" tabindex="-1">Graceful shutdown <a class="header-anchor" href="#graceful-shutdown" aria-label="Permalink to &quot;Graceful shutdown&quot;">​</a></h3><p>A typical pattern:</p><ol><li>request stop</li><li>wait for threads to finish</li></ol><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stop_async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stop_blocking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><hr><h2 id="notes-and-gotchas" tabindex="-1">Notes and gotchas <a class="header-anchor" href="#notes-and-gotchas" aria-label="Permalink to &quot;Notes and gotchas&quot;">​</a></h2><h3 id="port-validation" tabindex="-1">Port validation <a class="header-anchor" href="#port-validation" aria-label="Permalink to &quot;Port validation&quot;">​</a></h3><p>In <code>run()</code>:</p><ul><li>If port is not 0 and &lt; 1024, or &gt; 65535, it throws.</li></ul><p>That means:</p><ul><li>privileged ports (&lt;1024) are intentionally rejected unless the config uses port 0 or &gt;=1024.</li></ul><h3 id="head-requests" tabindex="-1">HEAD requests <a class="header-anchor" href="#head-requests" aria-label="Permalink to &quot;HEAD requests&quot;">​</a></h3><p>Not found handler:</p><ul><li>For <code>HEAD</code>, it does not write a body.</li></ul><p>Router layer:</p><ul><li>The router already has special handling for <code>HEAD</code> by trying to match <code>GET</code> if no <code>HEAD</code> route exists.</li><li>The not-found handler still treats HEAD separately.</li></ul><h3 id="stop-blocking-does-not-stop" tabindex="-1">stop_blocking() does not stop <a class="header-anchor" href="#stop-blocking-does-not-stop" aria-label="Permalink to &quot;stop_blocking() does not stop&quot;">​</a></h3><p>Current behavior:</p><ul><li><code>stop_blocking()</code> only waits for the executor to become idle and joins threads.</li><li>It does not close the acceptor or stop the io_context.</li><li>Call <code>stop_async()</code> before <code>stop_blocking()</code> if you want the threads to exit.</li></ul><h3 id="close-socket" tabindex="-1">close_socket() <a class="header-anchor" href="#close-socket" aria-label="Permalink to &quot;close_socket()&quot;">​</a></h3><p>There is a helper to shutdown and close a socket safely, but it is not used inside <code>HTTPServer.cpp</code> right now. Sessions likely manage their own socket lifecycle.</p><hr><h2 id="how-to-extend" tabindex="-1">How to extend <a class="header-anchor" href="#how-to-extend" aria-label="Permalink to &quot;How to extend&quot;">​</a></h2><h3 id="custom-404" tabindex="-1">Custom 404 <a class="header-anchor" href="#custom-404" aria-label="Permalink to &quot;Custom 404&quot;">​</a></h3><p>Replace the default:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setNotFoundHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([](</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">auto&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // build your response</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="dedicated-executors-heavy-routes" tabindex="-1">Dedicated executors (heavy routes) <a class="header-anchor" href="#dedicated-executors-heavy-routes" aria-label="Permalink to &quot;Dedicated executors (heavy routes)&quot;">​</a></h3><p>Heavy routes are detected and stored in <code>Router</code> nodes as <code>heavy</code>. A session or dispatcher can use:</p><ul><li><code>router.is_heavy(req)</code> to decide which executor to schedule on.</li></ul><hr><h2 id="checklist-for-production" tabindex="-1">Checklist for production <a class="header-anchor" href="#checklist-for-production" aria-label="Permalink to &quot;Checklist for production&quot;">​</a></h2><ul><li>Set <code>config_.getIOThreads()</code> explicitly if you need predictable I/O thread count.</li><li>Make sure your executor is sized for your workload (CPU-bound vs I/O-bound).</li><li>Always implement a signal handler to call <code>stop_async()</code> then <code>stop_blocking()</code>.</li><li>Ensure logging level is appropriate (metrics logs currently use Debug).</li></ul>`,113)])])}const E=s(l,[["render",n]]);export{g as __pageData,E as default};
