import{_ as i,o as s,c as a,a as t}from"./app.CG0w-bfk.js";import"./chunks/markjs.l6TISjdC.js";import"./chunks/minisearch.DigTKvvb.js";const g=JSON.parse('{"title":"Core Overview","description":"","frontmatter":{},"headers":[],"relativePath":"modules/core/index.md","filePath":"modules/core/index.md","lastUpdated":1770805184000}'),o={name:"modules/core/index.md"};function l(n,e,r,h,d,p){return s(),a("div",null,[...e[0]||(e[0]=[t(`<h1 id="core-overview" tabindex="-1">Core Overview <a class="header-anchor" href="#core-overview" aria-label="Permalink to &quot;Core Overview&quot;">​</a></h1><p>This page explains how the Vix.cpp core works at a high level. It is written for beginners coming from Python (FastAPI) or Node.js (Express).</p><h2 id="what-the-core-provides" tabindex="-1">What the core provides <a class="header-anchor" href="#what-the-core-provides" aria-label="Permalink to &quot;What the core provides&quot;">​</a></h2><p>Vix core is the runtime layer that makes these things work together:</p><ul><li>HTTP server (Boost.Asio + Boost.Beast)</li><li>Per-connection session handling (timeouts, basic safety checks)</li><li>Router (method + path matching, path params, optional heavy scheduling)</li><li>Request and response wrappers (simple route authoring)</li><li>Optional OpenAPI + Swagger UI (served locally with offline assets)</li><li>Executor and thread pool utilities for heavy workloads and periodic jobs</li></ul><p>In practice, you write routes. The core handles networking, parsing, dispatching, and concurrency.</p><h2 id="request-lifecycle-end-to-end" tabindex="-1">Request lifecycle (end to end) <a class="header-anchor" href="#request-lifecycle-end-to-end" aria-label="Permalink to &quot;Request lifecycle (end to end)&quot;">​</a></h2><p>A single HTTP request goes through this flow:</p><ol><li><strong>HTTPServer</strong> accepts a TCP connection.</li><li><strong>Session</strong> is created for that socket.</li><li>Session reads and parses an HTTP request (Beast parser).</li><li>Session applies basic checks: <ul><li>request body limit</li><li>timeout timer</li><li>optional WAF rules (URL and body patterns, configurable)</li></ul></li><li>Session asks the <strong>Router</strong> to match <code>method + path</code>.</li><li>If the route is marked <strong>heavy</strong>, Session posts it to the <strong>Executor</strong>. <ul><li>If not heavy, Session runs the route immediately on the I/O thread.</li></ul></li><li>The route handler writes a response.</li><li>Session writes the response back to the client.</li><li>If <code>keep-alive</code> is enabled, the same Session reads the next request on that socket.</li></ol><h3 id="why-this-architecture-exists" tabindex="-1">Why this architecture exists <a class="header-anchor" href="#why-this-architecture-exists" aria-label="Permalink to &quot;Why this architecture exists&quot;">​</a></h3><p>If you come from Node.js:</p><ul><li>Node has an event loop. Vix uses Asio I/O threads for networking.</li><li>You still want to avoid blocking I/O threads with CPU or DB-heavy work.</li><li>Heavy routes get scheduled on a dedicated executor so the server stays responsive.</li></ul><p>If you come from Python:</p><ul><li>FastAPI uses an async event loop and thread pools for blocking work.</li><li>Vix splits the same idea into I/O threads (network) and an executor (heavy tasks).</li></ul><h2 id="core-components" tabindex="-1">Core components <a class="header-anchor" href="#core-components" aria-label="Permalink to &quot;Core components&quot;">​</a></h2><h2 id="httpserver" tabindex="-1">HTTPServer <a class="header-anchor" href="#httpserver" aria-label="Permalink to &quot;HTTPServer&quot;">​</a></h2><p><strong>Role:</strong> Owns the <code>io_context</code>, TCP acceptor, and I/O threads.</p><p>Key behaviors:</p><ul><li>Initializes the acceptor and binds to the configured port.</li><li>Starts an async accept loop (<code>start_accept()</code>).</li><li>Launches multiple I/O worker threads (<code>io_context-&gt;run()</code>).</li><li>Spawns a <code>Session</code> per connection.</li><li>Runs a metrics monitor that periodically logs executor metrics.</li></ul><p>Useful details:</p><ul><li>If port is <code>0</code>, the OS picks an ephemeral port. You can read it via <code>bound_port()</code>.</li><li><code>calculate_io_thread_count()</code> uses <code>config.io_threads</code> if set, otherwise uses hardware concurrency.</li><li><code>stop_async()</code> closes the acceptor and stops the io_context.</li><li><code>stop_blocking()</code> waits for executor idle then joins threads.</li></ul><h2 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;Session&quot;">​</a></h2><p><strong>Role:</strong> Owns a single client connection, reads requests, routes them, writes responses.</p><p>Key behaviors:</p><ul><li>Uses a request parser and enforces <code>MAX_REQUEST_BODY_SIZE</code>.</li><li>Starts a per-request timeout timer and closes slow/stalled connections.</li><li>Optional WAF checks: <ul><li>WAF mode: <code>off</code>, <code>basic</code>, <code>strict</code></li><li>URL checks: length, null bytes, CR/LF, suspicious tokens</li><li>Body checks for mutating methods (POST/PUT/PATCH/DELETE)</li></ul></li><li>Uses a strand for serialized socket writes, so responses remain ordered and thread-safe.</li><li>Heavy routes are executed on the executor, then written back to the client on the strand.</li></ul><p>Important mental model:</p><ul><li>A Session is like a single <code>req/res</code> loop bound to one socket.</li><li>It may handle multiple requests if keep-alive is enabled.</li></ul><h2 id="router" tabindex="-1">Router <a class="header-anchor" href="#router" aria-label="Permalink to &quot;Router&quot;">​</a></h2><p><strong>Role:</strong> Matches <code>(HTTP method, path)</code> and dispatches to the registered handler.</p><p>Core ideas:</p><ul><li>Internally it uses a route tree, keyed by <code>METHOD + /path/segments</code>.</li><li>Path parameters are represented as <code>{name}</code>. They are stored in the tree using a wildcard key.</li><li>It supports HEAD fallback: if a HEAD route is not found, it can reuse GET.</li><li>It has a customizable not-found handler (default is JSON 404).</li></ul><h3 id="heavy-routes" tabindex="-1">Heavy routes <a class="header-anchor" href="#heavy-routes" aria-label="Permalink to &quot;Heavy routes&quot;">​</a></h3><p>A route can be marked as heavy using <code>RouteOptions{ .heavy = true }</code>.</p><p>What it means:</p><ul><li>Session will schedule the route on the executor.</li><li>This is the recommended way to isolate CPU-heavy or DB-heavy handlers.</li><li>The Router also exposes this in docs via <code>x-vix-heavy: true</code>.</li></ul><h2 id="openapi-and-docs" tabindex="-1">OpenAPI and Docs <a class="header-anchor" href="#openapi-and-docs" aria-label="Permalink to &quot;OpenAPI and Docs&quot;">​</a></h2><p>Vix can expose:</p><ul><li><code>GET /openapi.json</code> generated from the Router metadata and any extra docs registered by modules.</li><li>Swagger UI at: <ul><li><code>GET /docs</code></li><li><code>GET /docs/</code></li><li><code>GET /docs/index.html</code></li></ul></li><li>Offline assets: <ul><li><code>/docs/swagger-ui.css</code></li><li><code>/docs/swagger-ui-bundle.js</code></li></ul></li></ul><p>The UI is served locally, with Vix theme tokens, so the docs can work even without external CDNs.</p><h3 id="disable-auto-docs" tabindex="-1">Disable auto docs <a class="header-anchor" href="#disable-auto-docs" aria-label="Permalink to &quot;Disable auto docs&quot;">​</a></h3><p>If you want to disable automatic docs routes for a run, use:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vix</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> api.cpp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --no-docs</span></span></code></pre></div><h2 id="executor-threadpool-and-timers" tabindex="-1">Executor, ThreadPool, and timers <a class="header-anchor" href="#executor-threadpool-and-timers" aria-label="Permalink to &quot;Executor, ThreadPool, and timers&quot;">​</a></h2><p>Vix core supports separating lightweight request handling from heavy work.</p><h2 id="threadpool" tabindex="-1">ThreadPool <a class="header-anchor" href="#threadpool" aria-label="Permalink to &quot;ThreadPool&quot;">​</a></h2><p><strong>Role:</strong> Priority-based pool that executes tasks concurrently.</p><p>Key behaviors:</p><ul><li>Tasks have: <ul><li>a function</li><li>a priority</li><li>a sequence number for stable ordering</li></ul></li><li>The pool can grow threads up to <code>maxThreads</code> when saturated and backlog increases.</li><li><code>TaskGuard</code> tracks active tasks using RAII.</li><li>The pool can schedule periodic jobs via <code>periodicTask()</code>.</li><li>Metrics snapshot: <ul><li>pendingTasks</li><li>activeTasks</li><li>timedOutTasks</li></ul></li></ul><p>When to use it:</p><ul><li>CPU heavy operations (hashing, image work, large JSON processing)</li><li>DB work (if your DB client is blocking)</li><li>Any expensive logic you do not want on I/O threads</li></ul><h2 id="interval-timer" tabindex="-1">interval() timer <a class="header-anchor" href="#interval-timer" aria-label="Permalink to &quot;interval() timer&quot;">​</a></h2><p><strong>Role:</strong> Simple repeating timer that posts work onto an executor.</p><p><code>interval()</code> creates a tiny worker thread that wakes up every period and posts a task. It returns an RAII handle that stops and joins on destruction.</p><p>When to use it:</p><ul><li>periodic metrics logging</li><li>cache refresh jobs</li><li>background cleanup tasks</li></ul><p>Important rule:</p><ul><li>Keep the scheduled function fast, or schedule into a heavy executor if needed.</li></ul><h2 id="mental-mapping-for-node-js-and-python-developers" tabindex="-1">Mental mapping for Node.js and Python developers <a class="header-anchor" href="#mental-mapping-for-node-js-and-python-developers" aria-label="Permalink to &quot;Mental mapping for Node.js and Python developers&quot;">​</a></h2><h2 id="node-js-mapping-express" tabindex="-1">Node.js mapping (Express) <a class="header-anchor" href="#node-js-mapping-express" aria-label="Permalink to &quot;Node.js mapping (Express)&quot;">​</a></h2><ul><li><code>app.get(&quot;/path&quot;, handler)</code> feels like Express.</li><li><code>Request</code> is like <code>req</code>.</li><li><code>Response</code> is like <code>res</code>.</li><li>Heavy route scheduling is like pushing work into a worker pool.</li></ul><h2 id="python-mapping-fastapi" tabindex="-1">Python mapping (FastAPI) <a class="header-anchor" href="#python-mapping-fastapi" aria-label="Permalink to &quot;Python mapping (FastAPI)&quot;">​</a></h2><ul><li>Routes are simple functions.</li><li>Returning a JSON-like object can auto-send.</li><li>Heavy routes are conceptually similar to using thread pools for blocking work.</li></ul><h2 id="minimal-example" tabindex="-1">Minimal example <a class="header-anchor" href="#minimal-example" aria-label="Permalink to &quot;Minimal example&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix.hpp&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  App app;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [](</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Request</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Vix!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8080</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="practical-recommendations" tabindex="-1">Practical recommendations <a class="header-anchor" href="#practical-recommendations" aria-label="Permalink to &quot;Practical recommendations&quot;">​</a></h2><ul><li>Keep I/O threads clean: do not block them with CPU-heavy work.</li><li>Mark heavy endpoints as heavy and use an executor.</li><li>Use <code>keep-alive</code> where appropriate for performance.</li><li>Keep responses deterministic and always set proper status codes.</li><li>Start with the docs routes enabled. They help beginners discover the API quickly.</li></ul>`,66)])])}const m=i(o,[["render",l]]);export{g as __pageData,m as default};
