import{_ as i,o as a,c as n,a as e}from"./app.B6S_g6xJ.js";import"./chunks/markjs.l6TISjdC.js";import"./chunks/minisearch.DigTKvvb.js";const u=JSON.parse('{"title":"signal","description":"","frontmatter":{},"headers":[],"relativePath":"modules/async/signal.md","filePath":"modules/async/signal.md","lastUpdated":1770918867000}'),t={name:"modules/async/signal.md"};function l(h,s,p,o,r,c){return a(),n("div",null,[...s[0]||(s[0]=[e(`<h1 id="signal" tabindex="-1">signal <a class="header-anchor" href="#signal" aria-label="Permalink to &quot;signal&quot;">​</a></h1><p><code>signal_set</code> is a small asynchronous signal watcher designed to integrate POSIX signals into the Vix async runtime (<code>io_context</code> + <code>scheduler</code>).</p><p>It lets you:</p><ul><li>register signals you care about (<code>add</code>, <code>remove</code>)</li><li><code>co_await</code> the next signal via <code>async_wait()</code></li><li>optionally run a callback on each received signal (<code>on_signal</code>)</li><li>stop the watcher (<code>stop()</code>)</li></ul><p>This guide focuses on how to use the API, how it behaves, and what the important constraints are.</p><hr><h2 id="what-problem-does-this-solve" tabindex="-1">What problem does this solve? <a class="header-anchor" href="#what-problem-does-this-solve" aria-label="Permalink to &quot;What problem does this solve?&quot;">​</a></h2><p>Signals (like <code>SIGINT</code> when you press Ctrl+C) arrive outside your normal program flow.</p><p>If you want a clean shutdown in an async program, you typically want:</p><ul><li>a single place to observe signals</li><li>a way to <code>co_await</code> a signal in coroutines</li><li>delivery of completions on your scheduler thread (not on some random signal context)</li></ul><p><code>signal_set</code> provides that integration point.</p><hr><h2 id="design-model" tabindex="-1">Design model <a class="header-anchor" href="#design-model" aria-label="Permalink to &quot;Design model&quot;">​</a></h2><p><code>signal_set</code> is:</p><ul><li>bound to an <code>io_context</code></li><li>potentially backed by a dedicated worker thread (lazy start)</li><li>able to deliver signal events to: <ul><li>a single awaiting coroutine (single waiter model)</li><li>an optional callback</li></ul></li></ul><p>Important behaviors implied by the header:</p><ol><li><p><strong>Single waiter model</strong></p><ul><li><code>signal_set</code> stores one <code>std::coroutine_handle&lt;&gt; waiter_</code> and <code>bool waiter_active_</code>.</li><li>That strongly suggests only one <code>async_wait()</code> is intended at a time.</li><li>If you need multiple consumers, build a fan-out layer (e.g. channel/queue) on top.</li></ul></li><li><p><strong>Queue for pending signals</strong></p><ul><li>Captured signals are buffered in <code>pending_</code>.</li><li>If a signal arrives before you call <code>async_wait()</code>, it can be consumed later.</li></ul></li><li><p><strong>Callbacks run on the scheduler thread</strong></p><ul><li><code>on_signal(fn)</code> says the callback is posted via <code>io_context</code> posting mechanism.</li><li>That means your callback runs on the same thread that executes <code>ctx.run()</code>.</li></ul></li><li><p><strong>Cancellation support</strong></p><ul><li><code>async_wait(cancel_token)</code> integrates with Vix cancellation.</li><li>If cancellation is requested, the task should complete with a cancellation error or equivalent behavior (see your <code>task&lt;&gt;</code> contract).</li></ul></li><li><p><strong>Stop is explicit</strong></p><ul><li><code>stop()</code> requests shutdown and should wake any active waiter.</li></ul></li></ol><hr><h2 id="typical-usage" tabindex="-1">Typical usage <a class="header-anchor" href="#typical-usage" aria-label="Permalink to &quot;Typical usage&quot;">​</a></h2><h3 id="_1-basic-ctrl-c-handling" tabindex="-1">1) Basic Ctrl+C handling <a class="header-anchor" href="#_1-basic-ctrl-c-handling" aria-label="Permalink to &quot;1) Basic Ctrl+C handling&quot;">​</a></h3><p>In an async app, you often want Ctrl+C to request cancellation and let your tasks unwind.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix/async/core/io_context.hpp&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix/async/core/signal.hpp&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix/async/core/cancel.hpp&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;vix/async/core/task.hpp&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">app_main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">io_context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">signal_set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sigs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancel_source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> cs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Wait for SIGINT (Ctrl+C)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> co_await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)sig;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Request cancellation for the rest of the system</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request_cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  co_return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  io_context ctx;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // signal_set is a lazy watcher bound to ctx</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  signal_set </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sigs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Register SIGINT</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SIGINT);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cancel_source cs;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Start your app tasks (depends on your task runner API)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Example shape:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // vix::async::core::spawn(ctx, app_main(ctx, sigs, cs));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Notes:</p><ul><li>Register signals early (before <code>run</code>) so you do not miss early signals.</li><li>Ensure <code>ctx.run()</code> is running so posted completions can execute.</li></ul><h3 id="_2-using-a-callback-instead-of-awaiting" tabindex="-1">2) Using a callback instead of awaiting <a class="header-anchor" href="#_2-using-a-callback-instead-of-awaiting" aria-label="Permalink to &quot;2) Using a callback instead of awaiting&quot;">​</a></h3><p>Sometimes you just want a lightweight handler that flips a flag and triggers shutdown.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">signal_set</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sigs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SIGINT);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SIGTERM);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on_signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">](</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Runs on the scheduler thread</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Keep it short and safe.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request_cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>This is convenient when you do not want a dedicated coroutine waiting on signals.</p><h3 id="_3-supporting-both-callback-and-coroutine-wait" tabindex="-1">3) Supporting both callback and coroutine wait <a class="header-anchor" href="#_3-supporting-both-callback-and-coroutine-wait" aria-label="Permalink to &quot;3) Supporting both callback and coroutine wait&quot;">​</a></h3><p>You can do both:</p><ul><li>callback for immediate side effects</li><li>coroutine wait for structured shutdown sequencing</li></ul><p>Be careful to avoid duplicate actions (e.g. requesting cancel twice is usually fine).</p><hr><h2 id="api-reference" tabindex="-1">API reference <a class="header-anchor" href="#api-reference" aria-label="Permalink to &quot;API reference&quot;">​</a></h2><h3 id="signal-set-io-context-ctx" tabindex="-1"><code>signal_set(io_context&amp; ctx)</code> <a class="header-anchor" href="#signal-set-io-context-ctx" aria-label="Permalink to &quot;\`signal_set(io_context&amp; ctx)\`&quot;">​</a></h3><p>Binds the signal watcher to a runtime context.</p><p>The watcher can post completions and callbacks back onto <code>ctx</code> so they execute on the scheduler thread.</p><h3 id="void-add-int-sig" tabindex="-1"><code>void add(int sig)</code> <a class="header-anchor" href="#void-add-int-sig" aria-label="Permalink to &quot;\`void add(int sig)\`&quot;">​</a></h3><p>Register a signal number (e.g. <code>SIGINT</code>, <code>SIGTERM</code>) to observe.</p><p>The implementation may start the internal worker thread lazily on first registration or first wait.</p><h3 id="void-remove-int-sig" tabindex="-1"><code>void remove(int sig)</code> <a class="header-anchor" href="#void-remove-int-sig" aria-label="Permalink to &quot;\`void remove(int sig)\`&quot;">​</a></h3><p>Stop observing a given signal number.</p><p>If the signal is already pending in the queue, removal does not necessarily remove it from the pending queue.</p><h3 id="task-int-async-wait-cancel-token-ct" tabindex="-1"><code>task&lt;int&gt; async_wait(cancel_token ct = {})</code> <a class="header-anchor" href="#task-int-async-wait-cancel-token-ct" aria-label="Permalink to &quot;\`task&lt;int&gt; async_wait(cancel_token ct = {})\`&quot;">​</a></h3><p>Asynchronously wait for the next received signal.</p><p>Key behaviors:</p><ul><li>If <code>pending_</code> already contains a signal, the task can complete quickly by consuming it.</li><li>If no pending signal exists, the coroutine suspends and <code>waiter_</code> is stored.</li><li>Cancellation token may cancel the wait.</li></ul><p>Because the header stores a single waiter handle, assume:</p><ul><li>only one active <code>async_wait()</code> at a time</li><li>calling <code>async_wait()</code> again concurrently is either rejected, undefined, or causes overwrites</li></ul><p>If you need multiple waits, serialize them:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> co_await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ct);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // handle sig</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="void-on-signal-std-function-void-int-fn" tabindex="-1"><code>void on_signal(std::function&lt;void(int)&gt; fn)</code> <a class="header-anchor" href="#void-on-signal-std-function-void-int-fn" aria-label="Permalink to &quot;\`void on_signal(std::function&lt;void(int)&gt; fn)\`&quot;">​</a></h3><p>Register a callback invoked for each received signal.</p><p>The callback is posted onto the scheduler thread.</p><p>Rules of thumb:</p><ul><li>Keep it fast (no blocking I/O, no heavy work).</li><li>Delegate heavy work to other tasks using <code>ctx.post(...)</code> or your coroutine orchestration.</li></ul><h3 id="void-stop-noexcept" tabindex="-1"><code>void stop() noexcept</code> <a class="header-anchor" href="#void-stop-noexcept" aria-label="Permalink to &quot;\`void stop() noexcept\`&quot;">​</a></h3><p>Requests shutdown of the internal worker (if any) and wakes the active waiter (if any).</p><p>Use this if your program is exiting and you want to ensure:</p><ul><li>worker thread terminates</li><li>pending tasks can unblock</li></ul><hr><h2 id="threading-and-safety-notes" tabindex="-1">Threading and safety notes <a class="header-anchor" href="#threading-and-safety-notes" aria-label="Permalink to &quot;Threading and safety notes&quot;">​</a></h2><ul><li>Internal state is protected by a mutex (<code>m_</code>).</li><li>The worker thread captures signals and pushes them to <code>pending_</code>.</li><li>Delivery to coroutines/callbacks is done by posting onto <code>io_context</code> (scheduler thread).</li></ul><p>Practical implications:</p><ul><li>You should treat <code>signal_set</code> methods as thread-safe unless your implementation says otherwise.</li><li>Your callback runs on the scheduler thread, so it can safely touch scheduler-owned state if that state is also scheduler-thread-confined.</li><li>Do not assume callbacks run immediately after the signal arrives: they are queued via <code>ctx_post</code>.</li></ul><hr><h2 id="cancellation-behavior" tabindex="-1">Cancellation behavior <a class="header-anchor" href="#cancellation-behavior" aria-label="Permalink to &quot;Cancellation behavior&quot;">​</a></h2><p><code>async_wait(cancel_token)</code> indicates waiters can be cancelled.</p><p>Make sure your shutdown logic accounts for:</p><ul><li>cancellation requested before a signal arrives</li><li>stop() called while waiting</li><li>multiple signals arriving quickly</li></ul><p>A robust pattern is:</p><ul><li>request cancellation on signal</li><li>let other tasks watch the cancel token</li><li>stop the io_context once tasks have drained</li></ul><hr><h2 id="common-patterns" tabindex="-1">Common patterns <a class="header-anchor" href="#common-patterns" aria-label="Permalink to &quot;Common patterns&quot;">​</a></h2><h3 id="graceful-shutdown-signal-cancels-main-loop-exits" tabindex="-1">Graceful shutdown: signal cancels, main loop exits <a class="header-anchor" href="#graceful-shutdown-signal-cancels-main-loop-exits" aria-label="Permalink to &quot;Graceful shutdown: signal cancels, main loop exits&quot;">​</a></h3><ul><li>signal triggers cancellation</li><li>your main coroutine or control loop stops the context</li></ul><p>Pseudo:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> co_await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ct);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request_cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// wait for tasks to finish if you have a join mechanism</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="coalesce-repeated-signals" tabindex="-1">Coalesce repeated signals <a class="header-anchor" href="#coalesce-repeated-signals" aria-label="Permalink to &quot;Coalesce repeated signals&quot;">​</a></h3><p>If you press Ctrl+C multiple times, you may get multiple pending signals.</p><p>You can ignore subsequent ones:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> co_await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sigs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">async_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ct);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (first)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request_cancel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h2 id="practical-limitations" tabindex="-1">Practical limitations <a class="header-anchor" href="#practical-limitations" aria-label="Permalink to &quot;Practical limitations&quot;">​</a></h2><ol><li><p>POSIX-only by intent</p><ul><li>The header references POSIX signals (<code>&lt;csignal&gt;</code>).</li><li>On non-POSIX platforms, you may provide a stub or use <code>errc::not_supported</code>.</li></ul></li><li><p>Signal semantics are platform-dependent</p><ul><li>Delivery rules depend on process/thread masks.</li><li>If you do signal masking in other threads, document your expectation.</li></ul></li><li><p>Single waiter model</p><ul><li>If you need multiple consumers, build a small channel around it.</li></ul></li></ol><hr><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p><code>signal_set</code> is the async bridge from OS signals to Vix coroutines:</p><ul><li>register signals (<code>add</code>)</li><li>await the next signal (<code>async_wait</code>)</li><li>optional callback (<code>on_signal</code>) posted on the scheduler thread</li><li>stop cleanly (<code>stop</code>)</li></ul><p>It is small, explicit, and integrates into <code>io_context</code> without hiding complex behavior.</p>`,90)])])}const E=i(t,[["render",l]]);export{u as __pageData,E as default};
